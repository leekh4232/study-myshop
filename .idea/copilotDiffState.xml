<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/kr/hossam/myshop/MyApiResponseAdvice.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/kr/hossam/myshop/MyApiResponseAdvice.java" />
              <option name="originalContent" value="package kr.hossam.myshop;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.core.MethodParameter;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.http.converter.HttpMessageConverter;&#10;import org.springframework.http.server.ServerHttpRequest;&#10;import org.springframework.http.server.ServerHttpResponse;&#10;import org.springframework.http.server.ServletServerHttpResponse;&#10;import org.springframework.web.bind.annotation.ExceptionHandler;&#10;import org.springframework.web.bind.annotation.RestControllerAdvice;&#10;import org.springframework.web.context.request.ServletWebRequest;&#10;import org.springframework.web.context.request.WebRequest;&#10;import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;&#10;import kr.hossam.myshop.exceptions.MyException;&#10;import java.time.LocalDateTime;&#10;import java.util.HashMap;&#10;import java.util.LinkedHashMap;&#10;import java.util.Map;&#10;&#10;@Slf4j&#10;@RestControllerAdvice()&#10;public class MyApiResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; {&#10;&#10;    @Override&#10;    public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) {&#10;        // 모든 RestController의 응답을 처리하도록 true 반환&#10;        return true;&#10;    }&#10;&#10;&#10;    private static final Map&lt;String, HttpStatus&gt; EXCEPTION_STATUS_MAP = new HashMap&lt;&gt;();&#10;&#10;    static {&#10;        // 잘못된 요청에 대한 예외 처리 -&gt; 예: 잘못된 파라미터 값, 유효하지 않은 값 전달&#10;        EXCEPTION_STATUS_MAP.put(&quot;IllegalArgumentException&quot;, HttpStatus.BAD_REQUEST);&#10;&#10;        // 요청 파라미터 누락 -&gt; 예: 필수 쿼리 파라미터 또는 폼 파라미터가 없을 때&#10;        EXCEPTION_STATUS_MAP.put(&quot;MissingServletRequestParameterException&quot;, HttpStatus.BAD_REQUEST);&#10;&#10;        // 메서드 파라미터 타입 불일치 -&gt; 예: int 타입에 문자 전달, enum 타입에 잘못된 값 전달&#10;        EXCEPTION_STATUS_MAP.put(&quot;MethodArgumentTypeMismatchException&quot;, HttpStatus.BAD_REQUEST);&#10;&#10;        // JSON 파싱 실패 -&gt; 예: 잘못된 JSON 포맷, 타입 불일치, 바인딩 오류&#10;        EXCEPTION_STATUS_MAP.put(&quot;HttpMessageNotReadableException&quot;, HttpStatus.BAD_REQUEST);&#10;&#10;        // 지원하지 않는 HTTP 메서드 사용 -&gt; 예: GET만 지원하는 엔드포인트에 POST 요청&#10;        EXCEPTION_STATUS_MAP.put(&quot;HttpRequestMethodNotSupportedException&quot;, HttpStatus.METHOD_NOT_ALLOWED);&#10;&#10;        // 지원하지 않는 Content-Type -&gt; 예: application/json만 받는데 application/xml로 요청&#10;        EXCEPTION_STATUS_MAP.put(&quot;HttpMediaTypeNotSupportedException&quot;, HttpStatus.UNSUPPORTED_MEDIA_TYPE);&#10;&#10;        // Accept 헤더로 지원하지 않는 미디어 타입 요청 -&gt; 예: 서버가 text/plain만 제공하는데 application/json 요청&#10;        EXCEPTION_STATUS_MAP.put(&quot;HttpMediaTypeNotAcceptableException&quot;, HttpStatus.NOT_ACCEPTABLE);&#10;&#10;        // 인증은 되었으나 접근 권한이 없을 때 -&gt; 예: ROLE_USER가 접근 불가능한 관리자 페이지 요청&#10;        EXCEPTION_STATUS_MAP.put(&quot;AccessDeniedException&quot;, HttpStatus.FORBIDDEN);&#10;&#10;        // 인증이 되지 않았을 때 -&gt; 예: JWT 토큰 없거나 만료되어 요청 시&#10;        EXCEPTION_STATUS_MAP.put(&quot;AuthenticationException&quot;, HttpStatus.UNAUTHORIZED);&#10;&#10;        // 매핑되는 핸들러(컨트롤러)가 없을 때 -&gt; 예: 잘못된 URL로 접근&#10;        EXCEPTION_STATUS_MAP.put(&quot;NoHandlerFoundException&quot;, HttpStatus.NOT_FOUND);&#10;&#10;        // 이미 존재하는 엔티티 생성 시 충돌 -&gt; 예: 이미 존재하는 이메일로 회원가입 시도&#10;        EXCEPTION_STATUS_MAP.put(&quot;EntityExistsException&quot;, HttpStatus.CONFLICT);&#10;&#10;        // 데이터 무결성 제약 조건 위반 -&gt; 예: UNIQUE, FOREIGN KEY 위반&#10;        EXCEPTION_STATUS_MAP.put(&quot;DataIntegrityViolationException&quot;, HttpStatus.CONFLICT);&#10;&#10;        // Bean Validation 유효성 검사 실패 -&gt; 예: @NotNull, @Size 검사 실패&#10;        EXCEPTION_STATUS_MAP.put(&quot;ConstraintViolationException&quot;, HttpStatus.UNPROCESSABLE_ENTITY);&#10;&#10;        // NullPointerException 발생 시 -&gt; 예: 의도하지 않게 null 접근&#10;        EXCEPTION_STATUS_MAP.put(&quot;NullPointerException&quot;, HttpStatus.INTERNAL_SERVER_ERROR);&#10;&#10;        // 서비스 사용 불가 -&gt; 예: 유지보수 중, 서버 과부하&#10;        EXCEPTION_STATUS_MAP.put(&quot;ServiceUnavailableException&quot;, HttpStatus.SERVICE_UNAVAILABLE);&#10;    }&#10;&#10;    @ExceptionHandler(Exception.class)&#10;    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; myExceptionHandler(&#10;            Exception e,&#10;            WebRequest request) {&#10;        // RestController 타입이 아닐 경우 예외 처리하지 않고 null 반환&#10;        Object handler = request.getAttribute(&quot;org.springframework.web.servlet.HandlerMapping.bestMatchingHandler&quot;, 0);&#10;        if (handler instanceof org.springframework.web.method.HandlerMethod handlerMethod) {&#10;            Class&lt;?&gt; beanType = handlerMethod.getBeanType();&#10;            if (!beanType.isAnnotationPresent(org.springframework.web.bind.annotation.RestController.class)) {&#10;                return null;&#10;            }&#10;        }&#10;&#10;        ServletWebRequest servletWebRequest = (ServletWebRequest) request;&#10;&#10;        // 기본 상태 코드는 INTERNAL_SERVER_ERROR로 설정&#10;        int status = HttpStatus.INTERNAL_SERVER_ERROR.value();&#10;&#10;        if (e instanceof MyException myException) {&#10;            // MyException을 상속받은 예외는 클래스에 정의되어 있는 값으로 상태 코드를 설정&#10;            status = myException.getStatus().value();&#10;        } else {&#10;            // 그 외의 예외는 EXCEPTION_STATUS_MAP에서 매핑된 상태 코드로 설정&#10;            // 매핑되지 않은 예외는 INTERNAL_SERVER_ERROR로 처리&#10;            status = EXCEPTION_STATUS_MAP.getOrDefault(&#10;                    e.getClass().getSimpleName(),&#10;                    HttpStatus.INTERNAL_SERVER_ERROR&#10;            ).value();&#10;        }&#10;&#10;        log.error(&quot;========== Http {} Error =========&quot;, status);&#10;        log.error(e.getMessage(), e);&#10;&#10;        Map&lt;String, Object&gt; result = new LinkedHashMap&lt;&gt;();&#10;        result.put(&quot;status&quot;, status);&#10;        result.put(&quot;message&quot;, e.getMessage() != null ? e.getMessage() : HttpStatus.INTERNAL_SERVER_ERROR);&#10;        result.put(&quot;error&quot;, e.getClass().getSimpleName());&#10;&#10;        return ResponseEntity.status(status).body(result);&#10;    }&#10;&#10;    /**&#10;     * 응답 본문을 가공하는 메소드&#10;     */&#10;    @Override&#10;    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,&#10;                                  Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,&#10;                                  ServerHttpRequest request, ServerHttpResponse response) {&#10;&#10;        // JSON 응답인지 확인&#10;        boolean isJsonResponse = selectedContentType != null &amp;&amp; selectedContentType.includes(MediaType.APPLICATION_JSON);&#10;&#10;        // JSON 응답이 아닌 경우 원본 응답 반환&#10;        if (!isJsonResponse) {&#10;            return body;&#10;        }&#10;&#10;        // HTTP 응답 상태 코드 확인&#10;        int statusCode = HttpStatus.OK.value();&#10;        if (response instanceof ServletServerHttpResponse servletResponse) {&#10;            statusCode = servletResponse.getServletResponse().getStatus();&#10;        }&#10;&#10;        Map&lt;String, Object&gt; result = new LinkedHashMap&lt;&gt;();&#10;        result.put(&quot;status&quot;, statusCode);&#10;        result.put(&quot;message&quot;, &quot;OK&quot;);&#10;&#10;        // 컨트롤러의 응답 본문이 있을 경우 결과에 덧붙임&#10;        if (body != null &amp;&amp; body instanceof Map) {&#10;            result.putAll((Map&lt;String, Object&gt;) body);&#10;        }&#10;&#10;        result.put(&quot;timestamp&quot;, LocalDateTime.now().toString());&#10;        result.put(&quot;path&quot;, request.getURI().getPath());&#10;&#10;        return result;&#10;    }&#10;}" />
              <option name="updatedContent" value="package kr.hossam.myshop;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.core.MethodParameter;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.http.converter.HttpMessageConverter;&#10;import org.springframework.http.server.ServerHttpRequest;&#10;import org.springframework.http.server.ServerHttpResponse;&#10;import org.springframework.http.server.ServletServerHttpResponse;&#10;import org.springframework.web.bind.annotation.ExceptionHandler;&#10;import org.springframework.web.bind.annotation.RestControllerAdvice;&#10;import org.springframework.web.context.request.ServletWebRequest;&#10;import org.springframework.web.context.request.WebRequest;&#10;import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;&#10;import kr.hossam.myshop.exceptions.MyException;&#10;import java.time.LocalDateTime;&#10;import java.util.HashMap;&#10;import java.util.LinkedHashMap;&#10;import java.util.Map;&#10;&#10;@Slf4j&#10;@RestControllerAdvice()&#10;public class MyApiResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; {&#10;&#10;    @Override&#10;    public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) {&#10;        // 모든 RestController의 응답을 처리하도록 true 반환&#10;        return true;&#10;    }&#10;&#10;&#10;    private static final Map&lt;String, HttpStatus&gt; EXCEPTION_STATUS_MAP = new HashMap&lt;&gt;();&#10;&#10;    static {&#10;        // 잘못된 요청에 대한 예외 처리 -&gt; 예: 잘못된 파라미터 값, 유효하지 않은 값 전달&#10;        EXCEPTION_STATUS_MAP.put(&quot;IllegalArgumentException&quot;, HttpStatus.BAD_REQUEST);&#10;&#10;        // 요청 파라미터 누락 -&gt; 예: 필수 쿼리 파라미터 또는 폼 파라미터가 없을 때&#10;        EXCEPTION_STATUS_MAP.put(&quot;MissingServletRequestParameterException&quot;, HttpStatus.BAD_REQUEST);&#10;&#10;        // 메서드 파라미터 타입 불일치 -&gt; 예: int 타입에 문자 전달, enum 타입에 잘못된 값 전달&#10;        EXCEPTION_STATUS_MAP.put(&quot;MethodArgumentTypeMismatchException&quot;, HttpStatus.BAD_REQUEST);&#10;&#10;        // JSON 파싱 실패 -&gt; 예: 잘못된 JSON 포맷, 타입 불일치, 바인딩 오류&#10;        EXCEPTION_STATUS_MAP.put(&quot;HttpMessageNotReadableException&quot;, HttpStatus.BAD_REQUEST);&#10;&#10;        // 지원하지 않는 HTTP 메서드 사용 -&gt; 예: GET만 지원하는 엔드포인트에 POST 요청&#10;        EXCEPTION_STATUS_MAP.put(&quot;HttpRequestMethodNotSupportedException&quot;, HttpStatus.METHOD_NOT_ALLOWED);&#10;&#10;        // 지원하지 않는 Content-Type -&gt; 예: application/json만 받는데 application/xml로 요청&#10;        EXCEPTION_STATUS_MAP.put(&quot;HttpMediaTypeNotSupportedException&quot;, HttpStatus.UNSUPPORTED_MEDIA_TYPE);&#10;&#10;        // Accept 헤더로 지원하지 않는 미디어 타입 요청 -&gt; 예: 서버가 text/plain만 제공하는데 application/json 요청&#10;        EXCEPTION_STATUS_MAP.put(&quot;HttpMediaTypeNotAcceptableException&quot;, HttpStatus.NOT_ACCEPTABLE);&#10;&#10;        // 인증은 되었으나 접근 권한이 없을 때 -&gt; 예: ROLE_USER가 접근 불가능한 관리자 페이지 요청&#10;        EXCEPTION_STATUS_MAP.put(&quot;AccessDeniedException&quot;, HttpStatus.FORBIDDEN);&#10;&#10;        // 인증이 되지 않았을 때 -&gt; 예: JWT 토큰 없거나 만료되어 요청 시&#10;        EXCEPTION_STATUS_MAP.put(&quot;AuthenticationException&quot;, HttpStatus.UNAUTHORIZED);&#10;&#10;        // 매핑되는 핸들러(컨트롤러)가 없을 때 -&gt; 예: 잘못된 URL로 접근&#10;        EXCEPTION_STATUS_MAP.put(&quot;NoHandlerFoundException&quot;, HttpStatus.NOT_FOUND);&#10;&#10;        // 이미 존재하는 엔티티 생성 시 충돌 -&gt; 예: 이미 존재하는 이메일로 회원가입 시도&#10;        EXCEPTION_STATUS_MAP.put(&quot;EntityExistsException&quot;, HttpStatus.CONFLICT);&#10;&#10;        // 데이터 무결성 제약 조건 위반 -&gt; 예: UNIQUE, FOREIGN KEY 위반&#10;        EXCEPTION_STATUS_MAP.put(&quot;DataIntegrityViolationException&quot;, HttpStatus.CONFLICT);&#10;&#10;        // Bean Validation 유효성 검사 실패 -&gt; 예: @NotNull, @Size 검사 실패&#10;        EXCEPTION_STATUS_MAP.put(&quot;ConstraintViolationException&quot;, HttpStatus.UNPROCESSABLE_ENTITY);&#10;&#10;        // NullPointerException 발생 시 -&gt; 예: 의도하지 않게 null 접근&#10;        EXCEPTION_STATUS_MAP.put(&quot;NullPointerException&quot;, HttpStatus.INTERNAL_SERVER_ERROR);&#10;&#10;        // 서비스 사용 불가 -&gt; 예: 유지보수 중, 서버 과부하&#10;        EXCEPTION_STATUS_MAP.put(&quot;ServiceUnavailableException&quot;, HttpStatus.SERVICE_UNAVAILABLE);&#10;    }&#10;&#10;    @ExceptionHandler(Exception.class)&#10;    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; myExceptionHandler(&#10;            Exception e,&#10;            WebRequest request) {&#10;        // RestController 타입이 아닐 경우 예외 처리하지 않고 null 반환&#10;        Object handler = request.getAttribute(&quot;org.springframework.web.servlet.HandlerMapping.bestMatchingHandler&quot;, 0);&#10;        if (handler instanceof org.springframework.web.method.HandlerMethod handlerMethod) {&#10;            Class&lt;?&gt; beanType = handlerMethod.getBeanType();&#10;            if (!beanType.isAnnotationPresent(org.springframework.web.bind.annotation.RestController.class)) {&#10;                // RestController가 아니면 기존 view 처리 (예외를 다시 던져 DispatcherServlet이 처리하도록)&#10;                throw e;&#10;            }&#10;        }&#10;&#10;        ServletWebRequest servletWebRequest = (ServletWebRequest) request;&#10;&#10;        // 기본 상태 코드는 INTERNAL_SERVER_ERROR로 설정&#10;        int status = HttpStatus.INTERNAL_SERVER_ERROR.value();&#10;&#10;        if (e instanceof MyException myException) {&#10;            // MyException을 상속받은 예외는 클래스에 정의되어 있는 값으로 상태 코드를 설정&#10;            status = myException.getStatus().value();&#10;        } else {&#10;            // 그 외의 예외는 EXCEPTION_STATUS_MAP에서 매핑된 상태 코드로 설정&#10;            // 매핑되지 않은 예외는 INTERNAL_SERVER_ERROR로 처리&#10;            status = EXCEPTION_STATUS_MAP.getOrDefault(&#10;                    e.getClass().getSimpleName(),&#10;                    HttpStatus.INTERNAL_SERVER_ERROR&#10;            ).value();&#10;        }&#10;&#10;        log.error(&quot;========== Http {} Error =========&quot;, status);&#10;        log.error(e.getMessage(), e);&#10;&#10;        Map&lt;String, Object&gt; result = new LinkedHashMap&lt;&gt;();&#10;        result.put(&quot;status&quot;, status);&#10;        result.put(&quot;message&quot;, e.getMessage() != null ? e.getMessage() : HttpStatus.INTERNAL_SERVER_ERROR);&#10;        result.put(&quot;error&quot;, e.getClass().getSimpleName());&#10;&#10;        return ResponseEntity.status(status).body(result);&#10;    }&#10;&#10;    /**&#10;     * 응답 본문을 가공하는 메소드&#10;     */&#10;    @Override&#10;    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,&#10;                                  Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,&#10;                                  ServerHttpRequest request, ServerHttpResponse response) {&#10;&#10;        // JSON 응답인지 확인&#10;        boolean isJsonResponse = selectedContentType != null &amp;&amp; selectedContentType.includes(MediaType.APPLICATION_JSON);&#10;&#10;        // JSON 응답이 아닌 경우 원본 응답 반환&#10;        if (!isJsonResponse) {&#10;            return body;&#10;        }&#10;&#10;        // HTTP 응답 상태 코드 확인&#10;        int statusCode = HttpStatus.OK.value();&#10;        if (response instanceof ServletServerHttpResponse servletResponse) {&#10;            statusCode = servletResponse.getServletResponse().getStatus();&#10;        }&#10;&#10;        Map&lt;String, Object&gt; result = new LinkedHashMap&lt;&gt;();&#10;        result.put(&quot;status&quot;, statusCode);&#10;        result.put(&quot;message&quot;, &quot;OK&quot;);&#10;&#10;        // 컨트롤러의 응답 본문이 있을 경우 결과에 덧붙임&#10;        if (body != null &amp;&amp; body instanceof Map) {&#10;            result.putAll((Map&lt;String, Object&gt;) body);&#10;        }&#10;&#10;        result.put(&quot;timestamp&quot;, LocalDateTime.now().toString());&#10;        result.put(&quot;path&quot;, request.getURI().getPath());&#10;&#10;        return result;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>